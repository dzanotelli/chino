package custodia

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"time"
)


type UploadBlob struct {
	Id string `json:"blob_id"`
	ExpireDate time.Time `json:"expire_date"`

}

type BlobEnvelope struct {
	Blob map[string]interface{} `json:"blob"`
}

// Upload a new blob
// This is the starting point to begin to upload a new blob
// It returns an UploadBlob object which is used later to upload
// data to the server
func (ca *CustodiaAPIv1) CreateBlob(documentId string, fieldName string,
	fileName string) (*UploadBlob, error) {


	data := map[string]interface{}{"document_id": documentId,
		"field": fieldName, "file_name": fileName}
	resp, err := ca.Call("POST", "/blobs/" , data)
	if err != nil {
		return nil, err
	}
	blobEnvelope := BlobEnvelope{}
	if err := json.Unmarshal([]byte(resp), &blobEnvelope); err != nil {
		return nil, err
	}

	ub := &UploadBlob{
		Id: blobEnvelope.Blob["blob_id"].(string),
		ExpireDate: blobEnvelope.Blob["expire_date"].(time.Time),
	}

	return ub, nil
}

func (ca *CustodiaAPIv1) UploadChunk(ub *UploadBlob, data []byte,
	length int, offset int) error {
	url := fmt.Sprintf("/blobs/%s", ub.Id)

	// FIXME: this below is autogenerated to have an example, but must be
	//  rewritten using CustodiaAPIv1 client
	req, err := http.NewRequest("PATCH", url, bytes.NewReader(data))
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/octet-stream")
	req.Header.Set("Content-Length", fmt.Sprint(length))
	req.Header.Set("Content-Range", fmt.Sprintf("bytes %d-%d/%d", offset, offset+length-1, length))
	resp, err := ca.Client.Do(req)
	if err != nil {
		return err
	}
	if resp.StatusCode != 200 {
		return fmt.Errorf("error uploading chunk: %s", resp.Status)
	}
}
